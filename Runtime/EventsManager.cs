using System.Collections.Generic;namespace DesertImage.Events{    public interface IEventUnit    {        void ListenEvent<TEvent>(IListen listener);        void UnlistenEvent<TEvent>(IListen listener);        void SendEvent<TEvent>(TEvent @event);    }    public class EventsManager    {        private readonly Dictionary<int, List<IListen>> _eventList = new Dictionary<int, List<IListen>>();        private readonly Queue<RemoveQueueInstance> _removeQueue = new Queue<RemoveQueueInstance>();        private bool _isSendingInProcess;        private struct RemoveQueueInstance        {            public readonly List<IListen> Listeners;            public readonly IListen Listener;            public RemoveQueueInstance(List<IListen> listeners, IListen listener)            {                Listeners = listeners;                Listener = listener;            }        }        public void Clear()        {            _eventList.Clear();        }        #region ADD / REMOVE        public void Add<T>(IListen newListener)        {            var hash = typeof(T).GetHashCode();            if (_eventList.TryGetValue(hash, out var cachedListeners))            {                cachedListeners.Add(newListener);                _eventList[hash] = cachedListeners;                return;            }            _eventList.Add(hash, new List<IListen> { newListener });        }        public void Remove<T>(IListen listener)        {            if (listener == null) return;            var hash = typeof(T).GetHashCode();            if (!_eventList.TryGetValue(hash, out var cachedListeners)) return;            // if (_isSendingInProcess)            // {            //     _removeQueue.Enqueue(new RemoveQueueInstance(cachedListeners, listener));            // }            // else            // {            cachedListeners.Remove(listener);            // }        }        #endregion        private void ExecuteRemoveQueue()        {            while (_removeQueue.Count > 0)            {                var instance = _removeQueue.Dequeue();                instance.Listeners.Remove(instance.Listener);            }        }        #region SEND EVENT        public void Send<T>(T arguments = default)        {            var hash = typeof(T).GetHashCode();            if (!_eventList.TryGetValue(hash, out var cachedListeners)) return;            if (cachedListeners == null) return;            for (var i = 0; i < cachedListeners.Count; i++)            {                _isSendingInProcess = true;                var cachedListener = cachedListeners[i];                if (!(cachedListener is IListen<T> listener)) continue;                listener.HandleCallback(arguments);                _isSendingInProcess = true;            }            ExecuteRemoveQueue();            _isSendingInProcess = false;        }        #endregion    }}